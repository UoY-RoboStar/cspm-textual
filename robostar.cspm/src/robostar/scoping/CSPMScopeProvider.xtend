/*
 * generated by Xtext 2.25.0
 */
package robostar.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import robostar.cspm.PRef
import static robostar.cspm.CspmPackage.Literals.*
import org.eclipse.xtext.resource.EObjectDescription
import org.eclipse.xtext.scoping.impl.SimpleScope
import java.util.ArrayList
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.FilteringScope
import java.util.HashSet
import robostar.cspm.NameDecl
import java.util.Set
import robostar.cspm.Prefix
import robostar.cspm.StatementExpression

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class CSPMScopeProvider extends AbstractCSPMScopeProvider {

	override getScope(EObject context, EReference reference) {
		if (context instanceof PRef && reference == PREF__REF) {
			val result = new ArrayList
			// We take the global scope
			val scope = delegateGetScope(context,reference)
			
			val oscope = Scopes.scopeFor(NameDecls(context), scope)
			return oscope
//			
//			// We create a reflexive scope based on the reference, so that a PRef may refer to itself!
//			var lscope = new SimpleReflexiveScope(oscope, context)
//			
//			// We then filter the resulting scope [global -> local], such that it is not the case
//			// that the EObjectDescription is itself (ie, PRef refers to itself) and there is another
//			// EObjectDescription in the outer global scope. This is required to ensure we're faithful
//			// to FDR's scoping rule.
//			var fscope = new FilteringScope(lscope, [f| !(f.EObjectOrProxy == context && scope.getElements(f.name).exists[o|o.EObjectOrProxy!=context])])
//			
//			// Then need to scope per containing Expression
//			//NameDecls(context)
//			return fscope
		}
	}
	
	def dispatch Set<NameDecl> NameDecls(PRef pr) {
		if (pr.eContainer !== null)
			NameDecls(pr.eContainer)
		else
			return new HashSet<NameDecl>
	}
	
	def dispatch Set<NameDecl> NameDecls(StatementExpression sexpr) {
		return sexpr.stmts.map[s|s.eAllContents.filter(NameDecl).toSet].flatten.toSet
	}
	
	def dispatch Set<NameDecl> NameDecls(Prefix gp) {
		if (gp.left !== null)
			return gp.left.eAllContents.filter(NameDecl).toSet
		else
			return new HashSet<NameDecl>
	}
	
	def dispatch Set<NameDecl> NameDecls(EObject e) {
		if (e !== null && e.eContainer !== null) {
			return NameDecls(e.eContainer)
		} else {
			return new HashSet<NameDecl>()
		}
	}

}
