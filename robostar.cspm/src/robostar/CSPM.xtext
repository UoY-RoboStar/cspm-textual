/********************************************************************************
 * Copyright (c) 2014 University of York and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *   Pedro Ribeiro - initial definition
 ********************************************************************************/

grammar robostar.CSPM with org.eclipse.xtext.common.Terminals

generate cspm "http://robostar.cs.york.ac.uk/CSPM"

/***************************************************************************************
 * Top-level CSPM
 ***************************************************************************************/
CSPM:
	{CSPM} (definitions+=Definition)*
;

QualifiedName:
	ID ('::' ID)*
;

/***************************************************************************************
 * Terminals
 ***************************************************************************************/
terminal CHAR: "'" ('a'..'z'|'A'..'Z'|'_') "'";
@Override 
terminal WS: (' '|'\t'|'\r'|'\n')+;
@Override 
terminal ML_COMMENT	: '{-' -> '-}';
@Override 
terminal SL_COMMENT : '--' !('\n'|'\r')* ('\r'? '\n')?;
@Override 
terminal ID  		: ('a'..'z'|'A'..'Z') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')* ("'")*;
@Override
terminal STRING:	'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';

/***************************************************************************************
 * Definitions
 ***************************************************************************************/
Definition:
		Include 
	|	Assertion
	|	ChannelList
	| 	DataType
	|	SubType
	|	NameType
	| 	PrintStatement
	|	External
	|	Transparent
	|	Function
	| 	TimedSection
	|	Module
	|   ModuleInstance
	| 	TypeAnnotation
;

/***************************************************************************************
 * Imports and miscellaneous functions
 ***************************************************************************************/
External:
	'external' externals+=externals (',' externals+=externals)*
;

Transparent:
	'transparent' transparents+=transparents (',' transparents+=transparents)*
;

Include:
	'include' file=STRING
;

/***************************************************************************************
 * Assertions
 ***************************************************************************************/
Assertion:
	'assert' (
		RefinementAssertion |
		DeadlockAssertion |
		DivergenceAssertion |
		DeterminismAssertion |
		HasTraceAssertion
	)
;

RefinementAssertion:
	negated='not'? spec=Expression '[=' model=SemanticModel implementation=Expression //check=Check
;

DeadlockAssertion:
	negated='not'? proc=Expression ':' '[' 'deadlock' 'free' ('[' model=SemanticModel ']')? ']'
;

DivergenceAssertion:
	negated='not'? proc=Expression ':' '[' 'divergence' 'free' ('[' model=SemanticModel ']')? ']'
;

DeterminismAssertion:
	negated='not'? proc=Expression ':' '[' 'deterministic' ('[' model=SemanticModel ']')? ']'
;

HasTraceAssertion:
	negated='not'? proc=Expression ':' '[' 'has' 'trace' ']:' trace=Expression
;

enum SemanticModel:
	TRACES = 'T' |
	FAILURES = 'F' |
	FAILURESDIVERGENCES = 'FD'
;

/***************************************************************************************
 * Timed section
 ***************************************************************************************/
TimedSection:
	{TimedSection} 'Timed' '(' expr=Expression ')' '{' (definitions+=Definition)* '}'
;

/***************************************************************************************
 * Type and channel declarations
 ***************************************************************************************/
ChannelList:
	'channel' channels+=Channel (',' channels+=Channel)* (':' type=Expression)? 
;

Channel returns NameDecl:
	{Channel} name=ID
;

DataType returns NameDecl:
	{DataType} 'datatype' name=ID '=' constructors+=Constructor ('|' constructors+=Constructor)*
;

SubType returns NameDecl:
	{SubTyoe} 'subtype' name=ID '=' constructors+=Constructor ('|' constructors+=Constructor)*
;

NameType returns NameDecl:
	{NameType} 'nametype' name=ID '=' type=Expression
;

Constructor returns NameDecl:
	{Constructor} name=ID ('.' type=Expression)?
;

/***************************************************************************************
 * Modules
 ***************************************************************************************/
Module:
	{Module} 'module' name=ID ('(' params+=Pattern (',' params+=Pattern)* ')')?
	(definitions+=Definition)*
	'exports'
	(definitions+=Definition)*
	'endmodule'
;

ModuleInstance:
	'instance' name=ID '=' ref=[Module|QualifiedName] ('(' args+=Expression (',' args+=Expression)* ')')?
;

/***************************************************************************************
 * Statements
 ***************************************************************************************/
PrintStatement:
	'print' expr=Expression
;

// This can be either a function or a constant. If it's a function,
// then can optionally use pattern matching.
//
// NOTE: Unlike FDR, we do not support a function declaration with no arguments,
//		 that is, f() = e, is invalid here. While FDR does allow such a declaration,
//		 it does not seem sensible to support it.
//
//		 FDR also allows empty pattern matching via multiple empty argument functions:
//		 f() = e
//		 f() = f
//		 which adopt the upper definition f() = e.
Function returns NameDecl:
	{Function} name=ID ('(' args+=Pattern (',' args+=Pattern)* ')')? '=' any=Expression
;

/***************************************************************************************
 * Patterns
 ***************************************************************************************/
WildCardPattern returns Pattern:
	{WildCardPattern} '_'
;

VariablePattern returns NameDecl:
	{VariablePattern} name=ID
;

BasicPattern returns Pattern:
	VariablePattern | 
	WildCardPattern |
	ListPattern |
	LiteralPattern |
	ParenthesesPattern |
	SetPattern |
	TuplePattern
;

// left-associative, binds tighter than Concat.
ConcatPattern returns Pattern:
	BasicPattern ({ConcatPattern.left=current} '^' right=BasicPattern)*
;

// right-associative, binds less tighter than Concat.
Pattern returns Pattern:
	ConcatPattern ({DotPattern.left=current} '.' right=ConcatPattern)?
;

ListPattern returns Pattern:
	{ListPattern} '<' (patterns+=Pattern)? (',' patterns+=Pattern)* '>'
;

LiteralPattern returns Pattern:
	{IntPattern} value=INT |
	{StringPattern} value=STRING |
	{CharPattern} value=CHAR
;

ParenthesesPattern returns Pattern:
	{ParenthesesPattern} '(' pattern=Pattern ')'
;

SetPattern returns Pattern:
	{Set} '{' (pattern=Pattern)? '}'
;

TuplePattern returns Pattern:
	{TuplePattern} '(' patterns+=Pattern (',' patterns+=Pattern)* ')'
;

/***************************************************************************************
 * Expressions
 * 
 * See https://cocotec.io/fdr/manual/cspm/syntax.html for precedence information.
 ***************************************************************************************/ 
ProjectExp returns Expression:
	BasicExpression (
		{ProjectExp.left=current} '|\\' right=BasicExpression
	)*
;

RenameExp returns Expression:
	ProjectExp ({RenameExp.left=current} '[[' pairs+=RenamingPair (',' pairs+=RenamingPair)* ('|' stmts+=Statement (',' stmts+=Statement)*)? ']]')?
;

ConcatExp returns Expression:
	RenameExp (
		{ConcatExp.left=current} '^' right=RenameExp
	)*
;

ListLengthExp returns Expression:
	ConcatExp (
		{ListLengthExp.left=current} '#' right=ConcatExp
	)*
;

MultDivMod returns Expression:
	ListLengthExp (
		{MultExp.left=current} '*' right=ListLengthExp |
		{DivExp.left=current} '/' right=ListLengthExp |
		{ModExp.left=current} '%' right=ListLengthExp
	)*
;

PlusMinus returns Expression:
	MultDivMod (
		{PlusExp.left=current} '+' right=MultDivMod |
		{MinusExp.left=current} '-' right=MultDivMod
	)*
;

ComparisonExp2 returns Expression:
	PlusMinus ({LessThanOrEqualExp.left=current} '<=' right=PlusMinus |
			{LessThanExp.left=current} '<' right=PlusMinus |
			{GreaterThanOrEqualExp.left=current} '>=' right=PlusMinus |
			{EqualsExp.left=current} '==' right=PlusMinus |
			{NotEqualsExp.left=current} '!=' right=PlusMinus)?
;

// The following separate rule is needed because > is also used to terminate
// a list expression.
ComparisonExp returns Expression:
	ComparisonExp2 
		(	{GreaterThanExp.left=current} '>' right=ComparisonExp2 
		)?
;

NotExp returns Expression:
	ComparisonExp ({NotExp.left=current} 'not' right=ComparisonExp)*
;

AndExp returns Expression:
	NotExp ({AndExp.left=current} 'and' right=NotExp)*
;

OrExp returns Expression:
	AndExp ({OrExp.left=current} 'or' right=AndExp)*
;

ColonExp returns Expression:
	OrExp ({ColonExp.left=current} ':' right=OrExp)?
;

DotExp returns Expression:
	ColonExp ({DotExp.left=current} '.' right=DotExp)?
;

// ?e?x.y:{0.1} is possible
Decoration returns Expression:
	DotExp 
		({InputExp.left=current} '?' right=Pattern (':' expr=Expression)? | 
		 {OutputExp.left=current} '!' right=DotExp | 
		 {NondeterministicInput.left=current} '$' right=Pattern (':' expr=Expression)?
		)*
;

GPrefix returns Expression:
	Decoration (
		{Prefix.left=current} '->' right=GPrefix |
		{GuardedExpression.left=current} '&' right=GPrefix
	)?
;

SequentialComposition returns Expression:
	GPrefix ({SequentialComposition.left=current} ';' right=GPrefix)*
;

SlidingChoice returns Expression:
	SequentialComposition ({SlidingChoice.left=current} '[>' right=SequentialComposition)*
;

Interrupt returns Expression:
	SlidingChoice (
		({Interrupt.left=current} '/\\' right=SlidingChoice) |
		({SynchronisingInterrupt.left=current} '/+' cs=Expression '+\\' right=SlidingChoice)
	)*
;

ExternalChoice returns Expression:
	Interrupt (
		({ExternalChoice.left=current} '[]' right=Interrupt) | 
		({SynchronisingExternalChoice.left=current} '[+' cs=Expression '+]' right=Interrupt)
	)* 
;

InternalChoice returns Expression:
	ExternalChoice ({InternalChoice.left=current} '|~|' right=ExternalChoice)*
;

EGA returns Expression:
	InternalChoice (
		'[|' ( 		// Ambiguous, which implies backtracking for the parser.
			 		{Exception.left=current} cset=Expression '|>' right=InternalChoice 
			 	| 	{GeneralisedParallel.left=current} cset=Expression  '|]' right=InternalChoice )
		|	{AlphabetisedParallel.left=current} '[' lset=Expression '||' rset=Expression ']' right=InternalChoice 
		|	{LinkedParallel.left=current} '[' links+=Link ('|' stmts+=Statement (',' stmts+=Statement)*)? ']' right=InternalChoice
	 )?
;

Link:
	left=Expression '<->' right=Expression
;

Interleave returns Expression:
	EGA ({Interleave.left=current} '|||' right=EGA)*
;

Hide returns Expression:
	Interleave ({Hide.left=current} '\\' right=Interleave)*
;

DoublePatternExp returns Expression:
	Hide ({DoublePatternExp.left=current} '@@' right=Hide)?
;

BasicExpression returns Expression:
	CoreProcess |
	FunctionExp |
	{ParExp} '(' expr=Expression ')' |
	{TupleExp} '(' expr+=Expression ',' expr+=Expression (',' expr+=Expression)* ')' |
	PRef |
	StatementExpression |
	{IntegerExp} value=INT |
	{LambdaExp} '\\' patterns+=Pattern (',' patterns+=Pattern)* '@' expr=Expression |
	{StringExp} value=STRING |
	{CharExp} value=CHAR |
	{MapExp} '(|' mapping+=Mapping (',' mapping+=Mapping)* '|)' |
	{TrueExp} ('True'|'true') |
	{FalseExp} ('False'|'false') |
	{UnaryNotExp} 'not' expr=Expression |
	{Events} 'Events' |
	{Char} 'Char' |
	{Int} 'Int' |
	{Proc} 'Proc' 
;

CoreProcess:
	{Stop} 'STOP' |
	{Skip} 'SKIP' |
	{Chaos} 'CHAOS' SingleArgFunction |
	{Run} 'RUN' SingleArgFunction |
	{Wait} 'WAIT' SingleArgFunction
;

FunctionExp:
	CoreFunction | CompressionFunction | RelationFunction | DotFunction
;

CoreFunction:
	{Error} 'error' SingleArgFunction |
	{Show} 'show' SingleArgFunction |
	{SetCard} 'card' SingleArgFunction |
	{SetDiff} 'diff' '(' args+=Expression ','  args+=Expression ')' |
	{SetEmpty} 'empty' SingleArgFunction |
	{SetlInter} 'inter' '(' args+=Expression ',' args+=Expression ')' |
	{SetbInter} 'Inter' SingleArgFunction |
	{SetMember} 'member' '(' args+=Expression ',' args+=Expression ')' |
	{LSeq} 'seq' SingleArgFunction |
	{BSeq} 'Seq' SingleArgFunction |
	{Set}  'Set' SingleArgFunction |
	{SetLUnion} 'union' '(' args+=Expression ',' args+=Expression ')' |
	{SetBUnion} 'Union' SingleArgFunction |
	{SequenceConcat} 'concat' SingleArgFunction |
	{SequenceElem} 'elem' '(' args+=Expression ',' args+=Expression ')' |
	{SequenceHead} 'head' SingleArgFunction |
	{SequenceLength} 'length' SingleArgFunction |
	{SequenceNull} 'null' SingleArgFunction |
	{SequenceSet} 'set' SingleArgFunction |
	{SequenceTail} 'tail' SingleArgFunction |
	{EmptyMap} 'emptyMap' SingleArgFunction |
	{MapDelete} 'mapDelete' SingleArgFunction |
	{MapFromList} 'mapFromList' SingleArgFunction |
	{MapLookup} 'mapLookup' SingleArgFunction |
	{MapMember} 'mapMember' SingleArgFunction |
	{MapToList} 'mapToList' SingleArgFunction |
	{MapUpdate} 'mapUpdated' SingleArgFunction |
	{MapUpdateMultiple} 'mapUpdateMultiple' SingleArgFunction |
	{Map} 'Map' '(' args+=Expression ',' args+=Expression ')'
;

CompressionFunction:
	{Chase} 'chase' SingleArgFunction |
	{ChaseNoCache} 'chase_nocache' SingleArgFunction |
	{Deter} 'deter' SingleArgFunction |
	{Diamond} 'diamond' SingleArgFunction |
	{Dbisim} 'dbisim' SingleArgFunction |
	{Explicate} 'explicate' SingleArgFunction |
	{LazyEnumerate} 'lazyenumerate' SingleArgFunction |
	{FailureWatchdog} 'failure_watchdog' '(' args+=Expression ',' args+=Expression ',' args+=Expression ')' |
	{Normal} 'normal' SingleArgFunction |
	{Prioritise} 'prioritise' '(' args+=Expression ',' args+=Expression ')' |
	{PrioritiseNoCache} 'prioritise_nocache' '(' args+=Expression ',' args+=Expression ')' |
	{PrioritisePo} 'prioritisepo' '(' args+=Expression ',' args+=Expression ',' args+=Expression ',' args+=Expression ')' |
	{Sbisim} 'sbisim' SingleArgFunction |
	{TauLoopFactor} 'tau_loop_factor' SingleArgFunction |
	{TraceWatchdog} 'trace_watchdog' '(' args+=Expression ',' args+=Expression ',' args+=Expression ')' |
	{TimedPriority} 'timed_priority' SingleArgFunction |
	{Wbisim} 'wbisim' SingleArgFunction
;

enum externals:
	CHASE = 'chase' |
	CHASE_NO_CACHE = 'chase_no_cache' |
	DETER = 'deter' |
	FAILURE_WATCHDOE = 'failure_watchdog' |
	PRIORITISE = 'prioritise' |
	PRIORITISE_NOCACHE = 'prioritise_nocache' |
	PRIORITISEPO = 'prioritisepo' |
	TRACE_WATCHDOG = 'trace_watchdog' |
	MTRANSCLOSE = 'mtransclose' |
	RELATIONAL_IMAGE = 'relational_image' |
	RELATIONAL_INVERSE_IMAGE = 'relational_inverse_image' |
	TRANSPOSE = 'transpose'
;

enum transparents:
	DIAMOND = 'diamond' |
	DBISIM = 'dbisim' |
	EXPLICATE = 'explicate' |
	LAZYENUMERATE = 'lazyenumerate' |
	NORMAL = 'normal' |
	SBISIM = 'sbisim' |
	TAU_LOOP_FACTOR = 'tau_loop_factor' |
	WBISIM = 'wbisim'
;

RelationFunction:
	{MTransClose} 'mtransclose' SingleArgFunction |
	{RelationalImage} 'relational_image' SingleArgFunction |
	{RelationalInverseImage} 'relational_inverse_image' SingleArgFunction |
	{Transpose} 'transpose' SingleArgFunction
;

DotFunction:
	{Extensions} 'extensions' SingleArgFunction |
	{Productions} 'productions' SingleArgFunction
;

fragment SingleArgFunction:
	'(' args+=Expression ')'
;

RenamingPair:
	from=Expression '<-' to=Expression
;

StatementExpression returns Expression:
	SetExp | RangedSetExp | ListExp | RangedListExp | EnumeratedSetExp
;

// We have ComparisonExp2 rather than anything above, because otherwise a string such as <2>1> would be accepted,
// in which case should it could be a list <2> followed by an ill-formed string, or a list whose first element is an expression
// comparison? We eliminate the second interpretation, which is what FDR does as well.
ListExp returns StatementExpression:
	{ListExp} '<' (exprs+=ComparisonExp2 (',' exprs+=ComparisonExp2)*)? ('|' stmts+=Statement (',' stmts+=Statement)*)? '>'
;

RangedListExp returns StatementExpression:
	{RangedListExp} '<' left=Expression '..' right=Expression ('|' stmts+=Statement (',' stmts+=Statement)*)? '>'
;

SetExp returns StatementExpression:
	{SetExp} '{' (exprs+=Expression (',' exprs+=Expression)*)? ('|' stmts+=Statement (',' stmts+=Statement)*)? '}'
;

RangedSetExp returns StatementExpression:
	{RangedSetExp} '{' left=Expression '..' right=Expression ('|' stmts+=Statement (',' stmts+=Statement)*)? '}'
;

EnumeratedSetExp returns StatementExpression:
	{EnumeratedSetExp} '{|' (exprs+=Expression (',' exprs+=Expression)*)? ('|' stmts+=Statement (',' stmts+=Statement)*)? '|}'
;

Mapping:
	left=Expression '=>' right=Expression
;

PRef:
	{PRef} ref=[NameDecl|QualifiedName] ('(' args+=Expression (',' args+=Expression)* ')')?
;

LetExp returns Expression:
	{LetExp} 'let'
		(definitions+=Definition)*
	'within'
		expr=Expression
;

IfThenElse returns Expression:
	'if' condition=Expression 'then' true=Expression 'else' false=Expression
;

Expression:
	LetExp | IfThenElse | ReplicatedOps | DoublePatternExp
;

// Replicated operators

ReplicatedOps:
	{ReplicatedAlphabetisedParallel} '||' stmts+=Statement (',' stmts+=Statement)* '@' '[' ']' expr=Expression |
	{ReplicatedExternalChoice} '[]' stmts+=Statement (',' stmts+=Statement)* '@' expr=Expression |
	{ReplicatedGeneralisedPrallel} '[|' '|]' stmts+=Statement (',' stmts+=Statement)* '@' expr=Expression |
	{ReplicatedInterleave} '|||' stmts+=Statement (',' stmts+=Statement)* '@' expr=Expression |
	{ReplicatedInternalChoice} '|~|' stmts+=Statement (',' stmts+=Statement)* '@' expr=Expression |
	{ReplicatedLinkedParallel} '[' links+=Link (',' links+=Link)* ('|' lstmts+=Statement (',' lstmts+=Statement)*)? ']' stmts+=Statement (',' stmts+=Statement)* '@' expr=Expression |
	{ReplicatedSequentialComposition} ';' stmts+=Statement (',' stmts+=Statement)* '@' expr=Expression |
	{ReplicatedSynchronisingParallel} '[+' cset=Expression '+]' '@' expr=Expression
;

/***************************************************************************************
 * Statements
 ***************************************************************************************/
Statement:
	GeneratorStatement |
	SetGeneratorStatement |
	{PredicateStatement} expr=Expression
;

GeneratorStatement:
	pattern=Pattern '<-' expr=Expression
;

// This option is supported by FDR, but the official syntax is unclear in the manual.
SetGeneratorStatement:
	pattern=Pattern ':' expr=Expression
;

/***************************************************************************************
 * Type annotations
 ***************************************************************************************/
TypeAnnotation:
	{TypeAnnotation} ref=[Function] (',' refs+=[Function])* '::' (
		constraints+=Constraint '=>' |
		'(' constraints+=Constraint (',' constraints+=Constraint) ')' '=>'
	)? type=TypeConstructor
;

Constraint:
	typeConstraint=TypeConstraint type=TypeVariable
;

TypeConstructor returns TypeExpression:
	TypeExpression (
		  {DotType.left=current} '.' right=TypeConstructor
		| {DotableType.left=current} '=>' right=TypeConstructor
		| {ExtendableType.left=current} '=>*' right=TypeConstructor
		| {FunctionType.left=current} '->' right=TypeConstructor
	)*
;

TypeExpression returns TypeExpression:
	   TypeVariable
	 | {SetType} '{' type=TypeConstructor '}'
	 | {MapType} '(|' key=TypeConstructor '=>' value=TypeConstructor '|)' 
	 | {SequenceType} '<' type=TypeConstructor '>' 
	 | {TupleType} '(' types+=TypeConstructor (',' types+=TypeConstructor)* ')'
	 | {IntType} 'Int' 
	 | {BoolType} 'Bool' 
	 | {CharType} 'Char'
	 | {EventType} 'Event' 
	 | {ProcType} 'Proc'
;

TypeVariable returns TypeExpression:
	{TypeVariable} name=ID
;

enum TypeConstraint:
	EQ = 'Eq' |
	COMPLETE = 'Complete' |
	ORD = 'Ord' |
	SET = 'Set' |
	YIELDABLE = 'Yieldable'
;
